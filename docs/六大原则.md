# 设计模式六大原则

## 概述
六大原则包括：
* 单一职责原则
* 里氏替换原则
* 依赖倒置原则
* 接口隔离原则
* 迪米特法则
* 开闭原则

## 1.单一职责原则
### 概述
（SRP，Single Responsibility Principle）
一个接口实现单一的功能，而不是同时混杂多个功能。举例来讲，对于一个用户接口IUserInfo应该分为业务对象BO（Business Object）和业务逻辑Biz（Business Logic）。如图：
![](http://www.coding.wang/up/php/upload/default/201505/png/1431704756.png)
项目中经常采用的SRP图：
![](http://www.coding.wang/up/php/upload/default/201505/png/1431749254.png)

### 定义
>  应该有 且仅有一个 原因引起类的变更

### 单一职责原则的优点：
* 简化和纯化类的职能，降低类的复杂性
* 降低变更所造成的风险（功能变更引起对应接口的修改，不会造成其他功能对应接口的修改）
* 提高程序可读性和可维护性


### 注意
单一职责原则不仅使用与接口和类，还适用于方法
方法命名清晰明确，职能单一，能使程序更容易理解

### 实践
实现过程中需要权衡项目的工期、成本等其他因素。

---

## 2.里氏替换原则
### 概述
里氏替换原则（LSP，Liskov Substitution Principle）：
里氏替换原则是面向接口编程的理论基础，通过子类或实现类替换父类或接口，确保程序运行不会出现问题。

### 定义
> 所有引用基类的地方必须能够透明地使用其子类对象。
> 通俗点讲，父类能够出现的地方子类就可以出现，程序不会出现异常和错误，编程人员无需知道使用的是父类还是子类。

### 注意
在类中调用其他类时务必使用接口，如果不能使用接口则**证明**设计违反了里氏替换原则。
里氏替换原则一般是用来描述泛化关系的，它是泛化关系实现的理论基础。类与类的关系如果不能用泛化关系合理描述，则应考虑使用关联关系（包括关联、聚合、组合）或依赖关系。

### 最佳实践
对于类方法的描述，我们可以分为前置条件、方法本身、后置条件
为了维护里氏替换原则，我们应当这样约束子类覆盖（Override）的定义：
* 在类前面加上@Override
* 前置条件为：参数类型必须要是父类参数类型的子类或相同（否则无法实现覆盖，子类方法不会执行，这样子类就不能个性化其行为）
> 当子类覆盖父类时，java是单反派语言，在面向接口编程（IOP）时，容易造成程序逻辑混乱。这时，就要考虑传入参数类型（如接口类型）的定义(不能总是定义为基类)。（？）
* 后置条件为：返回值类型也必须是父类的子类或相同（若返回值是父类的超类，导致面向接口的编程无法实现）

---


## 3.依赖倒置原则
### 概述
依赖倒置原则（DIP，Dependency Inversion Principle）：
模块的组装、对象关系的描述通过引用接口来定义，而不是直接通过具体的类来描述。
该原则强调了我们要遵从面向接口编程（IOP，Interface Oriented Programming）
面向接口编程其实是通过挖掘类表面的关系 最终抽象成 接口之间的关系。 是一种**透过现象看本质**的过程。是对对象关系的纯化和提炼。

### 定义
> * 高层模块（整体）不应当底层模块（组成模块）；
> * 抽象不依赖与细节；
> * 细节依赖抽象。

### 注意
依赖传递的三种方式：
* 接口方法中声明
* 构造函数参数
* setter

### 最佳实践
1. 实际开发中依赖导致原则的使用：两个类之间有依赖关系，只要定制出两者的接口（或抽象类），接下来可以独立开发了。
> 测试驱动的开发TDD（Test-Driven Development）就是依赖倒置原则的高级应用
2. 实现要领：
	* 尽量使每个类都有接口或抽象类
	* 变量的表面类型尽量是接口或抽象类
	* 任何类都不要从具体的类派生
	* 不要覆盖基类的方法（否则可能影响依赖的稳定性，方法调用时可能造成程序逻辑混乱）
	* 结合里氏替换原则的最佳实践
3. 实际开发中完全做到依赖倒置原则很难，只要记住“面向接口编程”，尤其是大项目更应该如此

---

## 4.接口隔离原则
### 概述
细化或特殊化接口，保证接口功能的单一性和纯洁性

### 定义
> 一个类对另一个类的依赖应该建立在最小接口上

### 注意
* 接口尽可能小，为接口的用户定制服务，要高内聚
* 但不能过度细分，要保证单一职责原则（一个接口要能实现某个具体的不能再分的业务的功能时，不能再分了，再分就没有意义了）

### 最佳实践
* 一个接口只服务于一个子模块或业务逻辑
* 尽量减少不必要的public方法
* 合理把握接口粒度：粒度太小，接口太多；太大，无法提供定制服务。


---

## 5.迪米特法则
### 概述
迪米特法则（LoD，Law of Demeter）也称为最少知识原则（Least Knowledge Principle）。
类应该高内聚、低耦合
一个类之和朋友类（成员变量、方法的输入参数的类）交流。

### 定义
> 一个类对象对其他类对象有最少的了解。

### 注意
* 类之和朋友类进行交流（详见概述）
* 朋友类能完成的功能让朋友类去完成（别抢了别人的饭碗）
* 自己能完成的不要让别人完成

### 最佳实践
参见“注意”
利用迪米特法则尽量解耦，但切记把握尺度，“过犹不及”

---

## 6.开闭原则
### 概述
开闭原则是Java设计原则中最基础的设计原则

### 定义
> 软件实体（类、模块、方法）应该方便扩展，尽量做到不要修改

### 注意
开闭原则的使用：
* 抽象约束
> 参数类型、引用对象尽量使用接口和抽象类；接口和抽象类应尽量保持稳定；不使用接口和抽象类未定义的public方法
* 使用元数据（metadata）控制模块行为
> 元数据指的是描述环境和数据的数据，比如配置参数等。元数据的方式是 对扩展开放 的一种形式。
* 封装变化
> 找出项目中不稳定的点，利用23中设计模式对变化进行封装

### 最佳实践
制定强有力的项目规章和约束（例如某些约束方便程序扩展，大家都要遵守）
预知变化，找到项目中不稳定的点
灵活利用23种设计模式解决不稳定点的扩展，以备后期应对项目修改的风险

---






